SIGNALS – THEORETICAL QUESTIONS (DETAILED EXPLANATIONS)
1. Question:

Can you explain the concept of signals in programming? How are they used in Unix-like operating systems?

Answer (Explanation):
A signal is a software mechanism used by Unix-like operating systems to notify a process that a specific event has occurred. Signals are asynchronous in nature, meaning they can arrive at any time during the execution of a process.

Signals are used for:

Error notification (e.g., segmentation fault)

Process control (stop, continue, terminate)

Inter-process communication (lightweight notification)

In Unix-like systems, signals are identified by numbers and symbolic names such as SIGINT, SIGSEGV, and SIGTERM. When a signal is delivered, the kernel checks the signal’s disposition and either terminates the process, ignores it, stops it, or invokes a user-defined signal handler.

2. Question:

What are software interrupts and hardware interrupts? Mention potential issues when dealing with them.

Answer (Explanation):
Hardware interrupts are generated by external devices like keyboards, timers, network cards, or disk controllers to request CPU attention.

Software interrupts are generated by software instructions, such as system calls or processor exceptions (e.g., divide by zero).

Issues when dealing with interrupts include:

Interrupt latency (delay in servicing interrupts)

Priority inversion

Race conditions

Interrupt storms

Improper masking leading to missed interrupts

Efficient interrupt handling is critical for system stability and real-time performance.

3. Question:

What is a synchronous signal and an asynchronous signal? How can the process be used for both?

Answer (Explanation):
A synchronous signal is generated as a direct result of the execution of a specific instruction by a process. Examples include:

SIGSEGV (invalid memory access)

SIGFPE (divide by zero)

An asynchronous signal is generated independently of the process execution, such as:

SIGINT (Ctrl+C)

SIGTERM (termination request)

A process can handle both by installing signal handlers using signal() or sigaction(). The kernel determines the signal type and delivers it appropriately.

4. Question:

Who is responsible for generating signals?

Answer (Explanation):
Signals can be generated by:

Kernel: due to exceptions or internal events

Hardware: timers or device interrupts

User: keyboard signals like Ctrl+C

Other processes: using kill() or sigqueue()

The kernel ultimately delivers the signal after determining its source.

5. Question:

What is a signal handler?

Answer (Explanation):
A signal handler is a user-defined function that executes when a specific signal is delivered to a process.

It allows the process to:

Clean up resources

Log errors

Recover from faults

Override default behavior

Signal handlers are registered using signal() or sigaction().

6. Question:

Which system call is used to send a signal to the process?

Answer (Explanation):
The kill() system call is used to send signals to a process or process group.

Despite its name, kill() does not always terminate a process; it merely sends a signal whose behavior depends on the signal type and disposition.

7. Question:

Write a program to send a signal to itself (same process)?

Answer (Explanation):
A process can send a signal to itself using its own PID obtained via getpid().

The kernel treats it the same way as a signal sent by another process.

8. Question:

Explain the default action associated with the SIGKILL signal.

Answer (Explanation):
SIGKILL forcefully terminates a process immediately.

It cannot be:

Caught

Ignored

Blocked

This ensures that a process cannot prevent its own termination, making SIGKILL a last-resort signal.

9. Question:

How does a process handle a signal while it is executing in kernel mode?

Answer (Explanation):
When a process is executing in kernel mode, signal delivery is deferred.

The kernel marks the signal as pending and delivers it only when the process returns to user mode, ensuring kernel execution remains atomic and safe.

10. Question:

Describe the behavior of a process when it receives a SIGSEGV signal.

Answer (Explanation):
SIGSEGV occurs when a process accesses invalid memory.

By default:

The process is terminated

A core dump may be generated

This signal indicates serious programming errors such as dereferencing NULL or accessing freed memory.

11. Question:

What is the role of the sigwait() function in signal handling?

Answer (Explanation):
sigwait() allows a process or thread to synchronously wait for a signal.

Unlike asynchronous handlers, it blocks execution until one of the specified signals is received, making it useful in multithreaded applications.

12. Question:

Explain the concept of signal correlation in a distributed environment.

Answer (Explanation):
In distributed systems, signals cannot be delivered directly across machines.

Signal correlation refers to mapping signal semantics to equivalent messaging or notification mechanisms so that distributed processes respond consistently to events.

13. Question:

Explain how a process handles a signal while it is in the ready state.

Answer (Explanation):
If a process is in the ready state, the signal is recorded as pending.

When the scheduler selects the process for execution, the kernel delivers the signal before user-space execution resumes.

14. Question:

What is the role of the sigqueue() function in signal handling?

Answer (Explanation):
sigqueue() sends signals along with user-defined data.

It supports real-time signals that are queued, ensuring no signal loss and allowing data to be transferred with the signal.

15. Question:

Describe the interaction between signals and IPC mechanisms in Unix-like systems.

Answer (Explanation):
Signals provide event notification, while IPC mechanisms transfer data.

They are often used together—for example, a signal notifies a process that data is available in a pipe or message queue.

16. Question:

Explain how a process can determine the priority of a received signal.

Answer (Explanation):
Signal priority is determined by:

Signal number

Real-time signal ordering

Real-time signals have higher priority and are delivered in order.

17. Question:

What is the role of the sigaltstack() function?

Answer (Explanation):
sigaltstack() provides an alternate stack for signal handlers.

It is mainly used to handle stack overflow signals safely.

18. Question:

Explain how a process can determine whether a signal was sent by the kernel or another process.

Answer (Explanation):
Using sigaction() with SA_SIGINFO, the handler receives a siginfo_t structure.

This structure contains sender PID, UID, and signal source.

19. Question:

Describe the interaction between signals and system calls.

Answer (Explanation):
Signals can interrupt blocking system calls.

If interrupted, the system call may return EINTR or restart automatically depending on flags.

20. Question:

How does a process handle a signal while it is waiting for a semaphore?

Answer (Explanation):
The wait is interrupted, and control is transferred to the signal handler.

The semaphore operation may need to be retried.

21. Question:

Describe the difference between a signal handler and a signal mask.

Answer (Explanation):
A signal handler defines what to do when a signal arrives.

A signal mask defines which signals are blocked from delivery.

22. Question:

How does a process handle a signal while it is in the zombie state?

Answer (Explanation):
A zombie process cannot handle signals because it has already terminated.

Only minimal process information remains for the parent to collect.

23. Question:

Advantages and disadvantages of using signals for IPC?

Answer (Explanation):
Advantages: fast, simple, low overhead
Disadvantages: limited data, race conditions, unreliable ordering

24. Question:

Explain how a process handles a signal while it is in a sleep state.

Answer (Explanation):
The sleep is interrupted, and the process wakes up to handle the signal.

25. Question:

How does a process handle a signal while it is in a critical section?

Answer (Explanation):
Signals are usually blocked during critical sections to prevent inconsistent state.

26. Question:

Challenges of signal handling in multi-threaded programs?

Answer (Explanation):

Ambiguous delivery

Shared signal masks

Synchronization issues

Unexpected thread interruption

27. Question:

What is a race condition? Explain in signal context.

Answer (Explanation):
A race condition occurs when signal timing affects program correctness, such as a signal arriving before a handler is installed.

28. Question:

Deadlock caused or resolved by signals?

Answer (Explanation):
Signals may interrupt blocking calls and resolve deadlocks, but improper handling can also cause inconsistent locking.

29. Question:

How can you force a process to dump core?

Answer (Explanation):
By sending signals like SIGSEGV, SIGABRT, or SIGQUIT.

30. Question:

Implications of using setjmp() and longjmp() in signal handlers?

Answer (Explanation):
They can bypass cleanup code and leave resources in inconsistent states.

31. Question:

Difference between termination and suspending of a signal.

Answer (Explanation):
Termination ends process execution permanently, while suspension pauses execution.

32. Question:

How CPU accesses device registers?

Answer (Explanation):
Using memory-mapped I/O or port-mapped I/O.

33. Question:

What is an IRQ line?

Answer (Explanation):
An IRQ line is a hardware signal line used to request CPU service.

34. Question:

How do you find unique values for IRQ lines?

Answer (Explanation):
They are assigned by hardware architecture and managed by the interrupt controller.

35. Question:

When does an interrupt occur?

Answer (Explanation):
When a device or event requires immediate CPU attention.

36. Question:

What are exceptions and when do they occur?

Answer (Explanation):
Exceptions occur due to errors during instruction execution.

37. Question:

How does kernel inform parent that child terminated?

Answer (Explanation):
By sending SIGCHLD to the parent.

38. Question:

Which PCB member contains signal information?

Answer (Explanation):
Signal mask, pending signals, and signal handlers.

39–41. Question:

How do you modify signal behavior / disposition?

Answer (Explanation):
Using sigaction() to replace default behavior.

42. Question:

Why does a program crash?

Answer (Explanation):
Due to illegal memory access, arithmetic errors, or unhandled signals.

43. Question:

How do you install a signal handler from user space?

Answer (Explanation):
By calling sigaction() or signal().

44. Question:

How do you catch a signal?

Answer (Explanation):
By registering a signal handler.

45. Question:

What does <signal.h> contain?

Answer (Explanation):
Signal definitions, macros, and function prototypes.

46. Question:

How do you clear sa_mask?

Answer (Explanation):
Using sigemptyset().

47. Question:

Why are signals blocked?

Answer (Explanation):
To protect critical sections and avoid race conditions.

48. Question:

Signal 2 bit set to 1 means?

Answer (Explanation):
SIGINT is blocked.

49. Question:

How can we see blocked signals?

Answer (Explanation):
Using /proc/PID/status.

50–57. Remaining kernel/PCB/proc questions

Answer (Explanation):
User space cannot directly access PCB. Information is exposed via /proc. Only kernel modules can create proc entries. Signal handlers can be invoked directly like normal functions, but this is not actual signal delivery.
